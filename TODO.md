
# TODO list for Qwy3

## Performance

- Generate textures in an other thread (share the atlas) because it takes too long at the beginning and it is noticeable and annoying.
- Measure time taken by chunk management alone and make it better (stuff like deciding which chunk to mesh or generate is so bad currently that it is easy to speed up).
  - Minimize iterations over large numbers of chunks at every frame.
  - Have (fast) sets of chunk coords that indicate if it has a mesh, contains entities, etc. Only render the chunks with meshes.
    - Chunks should have a flag that says if it is sunch a set, one for every such set. This is important for when the chunk wants to know maybe to decide to get in/out of a set. The synchronisation of that information would become a concern, encapsulation may be of use here.
- Ray casting by player to target a block is neither correct nor performant, do it right.
- Use `RenderPassDescriptor::timestamp_writes` to query timestamps for renderpass beginning and end and display renderpass performances for each renderpass.
- Look into the `crossbeam` crate to see if it can help with better multithreading architecture than our homemade thread pool.

## Graphics

- Bring back the *adaptive* fog, find a way to make it confortable with unloaded chunks now that the loaded area can take any shape.
- **Fix** the *adaptive* fog radius adjustment that flickers strangely when it should change smoothly. It goes back and forth even when the player is not moving and no chunk is unloading and thus when there is no reason for the worst case distance to unmeshed chunks to decrease.
- **Fix** the fact that some block types appear slightly transparent (visible on some block types in a worlds generated by the `structures-generated-blocks` generator). This happened since adding the fog. Disableing the fog doesn't remove the transparency on these blocks (but disableing the fog actually just expands it a lot).
- Have more than one fog shpere to help display more chunks when the loaded area have a shape that is not spherical.
  - Maybe start with just a second fog sphere that follows the player more slowly.
  - Maybe have fog spheres that try to move in directions that maximize the loaded volume covered while not uncovering unloaded areas, same thing with adjusting their radius.
- Slowly rotating skybox.
- Smooth transition between skyboxes, like when the better skybox finishes to generate it should fade in instead of replacing the old one in an instant.
- Procedural sky texture with nice variety.
- Small stars and stuff like wierd celestial bodies on the skybox.
- Cascading shadow mapping. Currently there is a single shadow map, but there should be multiple shadow maps corresponding to bigger and bigger areas so that shadows can be rendered even for far away stuff but without using as much resolution as for shadows close to the player.
- Sun. It could look like a 4-branch star in the style of star effects in Kill la Kill.
- God rays effect when looking at sun. I recall it can be done by rendering just the sun in white and all the world in black and doing some motion blur on the result, maybe?
- Glow effect.

## UI

- Maybe introduce type aliases to better label weather we are after or before the correction by `2.0/window_with`.
- Better and more general loading bar widget.

## Controls

- Add controler support (see the `gilrs` crate).
- Add customization of some controls not currently customizable, such as the mouse wheel (both vertical and horizontal) or the escape key.
- Add mouse back and forward button names (they were added in the last major winit release).
- Auto default configure the walking keys to ZQSD or WASD by detecting the keyboard layout.
- Differentiate between left and right same keys (like left shift and right shift) by adding a `winit::keyboardKeyLocation` in `Control::KeyboardKey`.

## Binary command line interface

- Allow to provide qwy script commands at binary invocation time that are to be executed during loading or after the first frame or something.

## Command Language

- Add commands to interface with the game.
- Add strings.
- Add a logging function.
- Add a way to define new typed global variables.
- Add a way to set variables.
- Add floating point numbers.

## World

- Procedurally generated types of block.
  - Procedurally generated textures for these types of blocks.
  - Procedurally generated properties.
- Generation of (procedurally generated types of) structures.
  - Structure types are procedurally generated (meaning that a type of tree found in a world will not be found in other worlds).
    - This can be done by making the structure type be an algorithm that can be procedurally generated (it is just a tree).
  - Factorize ot of the world generators that uses structures the structure generation "engine"! And make it actually readable.

## Mechanics and Gameplay

- Collision physics. The player box should not be able to overlap with non-pass-through blocks, but should be able to slide on walls and walk on the floor and stuff. Beware, this is way more difficult to implement in a sane way than it looks.
- Entities!!
  - Particles, like when breaking blocks.
  - Falling blocks.
  - Animals >w< or something.
- Liquids!!
  - Pools of liquid, keeping track of the volume of the pool, all the block coordinates that has some of it, the height of the liquid (z-coord of its surface), etc.
  - Handle the case when a pool of liquid has to flow due to a hole in a neighboring block.
  - Handle gigantic pools of liquid (like a sea or an ocean) that cannot be generated all at once and all and that we can safely consider to contain an infinite amount of liquid.
- Magic system!!
  - Runes, typing runes, casting.
  - Procedural grammar and mapping of elementary spells to their effects.
    - Make sure there are plenty of effects thta can be generated procedurally in the elementary spell map.
  - Mana.
  - Etc. (magic circles, engraving runes on blocks, etc.)
- "Survival" game mode with health and limitations and stuff.
  - Can only carry one block at a time. Once a block is broken it falls and can be picked up without any tool. Breaking a block doesn't take any time.
  - Respawns from eggs. Eggs are generated by the world gen.
  - Organ tree in each animal (player included).
- Gods.
  - Through some mechanic (to be decided, like a command or a spell or finding a temple or an altar or building an altar or performing some ritual or something), the player can pray to one god among a pool of possible gods.
  - Praying to a god grants a divine blessing that depends on the god, like more jumps or flying, infinite or more mana, always being able to see owns organ tree, some other abilities, etc.
  - Divine blessings come at some cost that depends on the god too, like some bosses that are summoned later to challenge you.
  - Can pray to multiple gods, the effects can stack.

## Saves

- Have saves. Launching the game on a new save or launching the game on a pre-existing save should not be the same.
  - Saves should at least be named and contain parameters and stuff like chunk side length.
- Save chunk data to disk when unloading.
  - And load chunk data from disk when loading.
- Save the skybox faces to the disk and load it.
- Save the texture atlas faces to the disk and load it.

## Multiplayer

- Multiplayer. Allow the game to become a client or a server.
  - At least play on the same world generated by the server only. Use something like https://github.com/TimonPost/laminar to send chunk data from the server to clients (it allows for reliable but unordered channels that seem fast (but still reliable!)!).
  - Events should be broadcasted.

## Other

- Profile (maybe with https://github.com/killercup/cargo-flamegraph or something else).
- Profile but with https://github.com/plasma-umass/coz maybe?
- Reduce the length of `lib.rs` and the `run` function!
- More info in the README, like control bindings syntax, default controls, command line arguments, etc.
- Find a better name? Idk.. Probably not tho, I like it that way ^^
