
# TODO list for Qwy3

## Performance

- Apply optimizations mentioned in https://youtu.be/40JzyaOYJeY (some of which are very clever)!
- Measure time taken by chunk management alone and make it better (stuff like deciding which chunk to mesh or generate is so bad currently that it is easy to speed up).
  - Minimize iterations over large numbers of chunks at every frame.
- Ray casting by player to target a block is neither correct nor performant, do it right.
- Use `RenderPassDescriptor::timestamp_writes` to query timestamps for renderpass beginning and end and display renderpass performances for each renderpass.
- Look into the `crossbeam` crate to see if it can help with better multithreading architecture than our homemade thread pool.
- Faster noise.
  - Allow to generate N values at once (to sample vectors instead of single values) in one sampling call.
  - Pre hash all the per-noise channel values.
  - Cache some node values?

## Correction

- Make the distribution of noise values at nodes of the noise implementation to be uniform by using the same technique that random number generators use to generate floats in uniform distrucbutions. A certain crate does [this](https://github.com/engusmaze/frand/blob/2305cf97832a26dddfd0f7d5679f56b061f6c834/src/gen/float.rs#L9) and cite [this](https://mina86.com/2016/random-reals/) as a source which links to [this](https://github.com/mina86/random-reals/blob/3a614a9c9f2d1298682321d1c7abd463ab8f68f3/make-real.h#L65). The we could actually assume that sampling the noise at the nodes (all integer parameters) would pick values in a uniform distribution.

## Graphics

- Slowly rotating skybox.
- Smooth transition between skyboxes, like when the better skybox finishes to generate it should fade in instead of replacing the old one in an instant.
- Procedural sky texture with nice variety.
- Small stars and stuff like wierd celestial bodies on the skybox.
- Sun. It could look like a 4-branch star in the style of star effects in Kill la Kill.
- God rays effect when looking at sun. I recall it can be done by rendering just the sun in white and all the world in black and doing some motion blur on the result, maybe?
- Glow effect.
- If there is a way (simple enough to be worth it) to get shadows to be semi-transparent as the casters fade in the fog, then do it, but note that naive solutions do not work as there is a problem: a semi-transparent caster block A casts on an opaque block B that casts on an other block C, the shadow from A to B should be semi-transparent and the shadow from B to C should be full but a single shadow map per cascade does not support multiple casters per texel, and both the shadow from A to B and the shadow from B to C must be preserved as the player could see both so we cannot discard one of these.
  - Seems possible with only twice the shadow maps. One shadow map for opaque casters, and one shadow map for semi-transparent casters (discading the second traversal of the fog by sun rays).

### Fog

- Bring back the *adaptive* fog, find a way to make it confortable with unloaded chunks now that the loaded area can take any shape.
- **Fix** the *adaptive* fog radius adjustment that flickers strangely when it should change smoothly. It goes back and forth even when the player is not moving and no chunk is unloading and thus when there is no reason for the worst case distance to unmeshed chunks to decrease.
- **Fix** the fact that some block types appear slightly transparent (visible on some block types in a worlds generated by the `structures-generated-blocks` generator). This happened since adding the fog. Disableing the fog doesn't remove the transparency on these blocks (but disableing the fog actually just expands it a lot).
- Have more than one fog shpere to help display more chunks when the loaded area have a shape that is not spherical.
  - Maybe start with just a second fog sphere that follows the player more slowly.
  - Maybe have fog spheres that try to move in directions that maximize the loaded volume covered while not uncovering unloaded areas, same thing with adjusting their radius.

## UI

- Maybe introduce type aliases to better label weather we are after or before the correction by `2.0/window_with`.
- Better and more general loading bar widget.
- Add some menus.
  - Save selection.
  - Save creation.
    - Text bar widgets for the name, the seed, etc.
	 - Selector widget to allow to select the world generator.
	 - Checkbox widgets for settings like `only_save_modified_chunks`.
  - Settings, like vsync and fps cap, playing mode, loading distance, fog margin, shadow map cascades number, sizes and common resolution, etc.
- When we pickup a block or place it back, instead of an instantaneous teleportation of the block into our hand, it should rather be a very quick but still visible animation of the block moving and rotating from its original position to where it must now be (our hand (in 3D) or aligned on the grid in the world).

## Controls

- Add controler support (see the `gilrs` crate).
- Add customization of some controls not currently customizable, such as the mouse wheel (both vertical and horizontal) or the escape key.
- Add mouse back and forward button names (they were added in the last major winit release).
- Auto default configure the walking keys to ZQSD or WASD by detecting the keyboard layout.
- Differentiate between left and right same keys (like left shift and right shift) by adding a `winit::keyboardKeyLocation` in `Control::KeyboardKey`.

## Binary command line interface

- Allow to provide qwy script commands at binary invocation time that are to be executed during loading or after the first frame or something.

## Command Language

- Add commands to interface with the game.
- Add strings.
- Add a logging function.
- Add a way to define new typed global variables.
- Add a way to set variables.
- Add floating point numbers.

## World

- Structure engine.
  - Set a maximum bounding box dimensions, then allow structures to declare their (potentially smaller) bounding box to already eliminate small structures too far from the chunk while still allowing very big structures.
- Procedurally generated types of block.
  - Procedurally generated textures for these types of blocks (that actually are somewhat related to the block vibes, like if the block is made to be like wood or leaf the texture should at least try to feel like wood or something).
  - Procedurally generated properties.
- Generation of (procedurally generated types of) structures.
  - Structure types are procedurally generated (meaning that a type of tree found in a world will not be found in other worlds).
    - This can be done by making the structure type be an algorithm that can be procedurally generated (it is just a tree).
  - Factorize ot of the world generators that uses structures the structure generation "engine"! And make it actually readable.
- Procedurally generated biome types, and actually using them in some world generators.

## Entities

- Make it so that chunks load ahead of the entities instead of waiting for entities to get "stuck" in unloaded chunks to start loading them.
- Support the throwing of X-shaped blocks.
- Particles, like when breaking blocks.
- Animals >w< or something.
- Procedurally generated types of animals.
  - Procedurally generated anatomy.
  - Procedurally generated abilities.
  - Procedurally generated goals.
- Make it so that the entities are managed by an other thread (so that the framerate is not going down due to the CPU-side handling of entities). That would also allow to make the entities be handled with a smaller frequency, independant from the framerate. That would require some interpolation between entity handling steps.

## Mechanics and Gameplay

- Magic system!!
  - Runes, typing runes, casting.
  - Procedural grammar and mapping of elementary spells to their effects.
    - Make sure there are plenty of effects thta can be generated procedurally in the elementary spell map.
  - Mana.
  - Etc. (magic circles, engraving runes on blocks, etc.)
- "Play" playing mode with health and limitations and stuff (as opposed to the "free" playing mode that has no challenge and hands all the tools to cheat).
  - Can only carry one block at a time. Once a block is broken it falls and can be picked up without any tool. Breaking a block doesn't take any time. (Kind of done ^^.)
  - Respawns from eggs. Eggs are generated by the world gen.
- Status grid in "play" mode.
  - There is a life bar and a food bar and a mana bar. They are not just bars, but instead lines in a grid of square cells. For example, the life bar can have hearts in it (they align themselves on the right to that there is no gap), but the hearts can be different and all. The food bar is one line above the life bar and iteracts with it: When food is eaten, a food symbol gets to try to fit in the food bar, and if the food bar gets bigger than the life bar then it is processed, emptied, and a new heart gets added to the life bar. The objects in this grid can interact with eachother and the player's properties. Some types of symbols can be procedurally generated (like special hearts and special foods that interact with the status grid in new procedurally generated ways).
- Liquids!!
  - Pools of liquid, keeping track of the volume of the pool, all the block coordinates that has some of it, the height of the liquid (z-coord of its surface), etc.
  - Handle the case when a pool of liquid has to flow due to a hole in a neighboring block.
  - Handle gigantic pools of liquid (like a sea or an ocean) that cannot be generated all at once and all and that we can safely consider to contain an infinite amount of liquid.
- Gods.
  - Through some mechanic (to be decided, like a command or a spell or finding a temple or an altar or building an altar or performing some ritual or something), the player can pray to one god among a pool of possible gods.
  - Praying to a god grants a divine blessing that depends on the god, like more jumps or flying, infinite or more mana, always being able to see owns organ tree, some other abilities, etc.
  - Divine blessings come at some cost that depends on the god too, like some bosses that are summoned later to challenge you.
  - Can pray to multiple gods, the effects can stack.
- Portals.
  - Opened via magic and/or found in the world.
  - A surface streched along a small flat hole with the same flat hole shape and the same blocks on the edges at the other end, so that the transition is unnoticeable. It should just look and feel like a hole that lead to elsewhere than what is actually behind the hole if we look behind.
  - Chunks must load on the other side as well, and entities that are near or overlapping the portal must be carefully handled so that it looks and feel good.

## Saves

- Make the saves be more resistant to panics. For now, even the `StateSavable` is lost if the game panics before being closed for the first time in a save. Loaded entities are lost on a panic. Changes made to the blocks of the loaded chunks are lost on a panic. This is too fragile and may lead to lots of frustration.

## Multiplayer

- Multiplayer. Allow the game to become a client or a server.
  - At least play on the same world generated by the server only. Use something like https://github.com/TimonPost/laminar to send chunk data from the server to clients (it allows for reliable but unordered channels that seem fast (but still reliable!)!).
  - Events should be broadcasted.

## Other

- Profile (maybe with https://github.com/killercup/cargo-flamegraph or something else).
- Profile but with https://github.com/plasma-umass/coz maybe?
- Reduce the length of `lib.rs` and the `run_game_loop` function.
- More info in the README, like control bindings syntax, default controls, command line arguments, etc.
- Find a better name? Idk.. Probably not tho, I like it that way ^^
- Move the code in `unsorted.rs` to better suited modules.
